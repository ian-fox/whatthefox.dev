<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta content="#ffffff" name="theme-color" />
  <meta content="#da532c" name="msapplication-TileColor" />

  
  <link href='&#x2F;icons&#x2F;site.webmanifest' rel="manifest" />
  
  
  <link color="#5bbad5" href='&#x2F;icons&#x2F;safari-pinned-tab.svg' rel="mask-icon" />
  
  
  <link href='&#x2F;icons&#x2F;favicon-16x16.png' rel="icon" sizes="16x16" type="image/png" />
  
  
  <link href='&#x2F;icons&#x2F;favicon-32x32.png' rel="icon" sizes="32x32" type="image/png" />
  
  
  <link href='&#x2F;icons&#x2F;apple-touch-icon.png' rel="apple-touch-icon" sizes="180x180" />
  

  

  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css" integrity="sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link href="https://whatthefox.dev/deep-thought.css" rel="stylesheet" />
  <link href="https://whatthefox.dev/css/whatthefox.css" rel="stylesheet" />

  <title>
    
What the ðŸ¦Š? | Crabtrap

  </title>

  
  
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mathtex-script-type.min.js" integrity="sha384-jiBVvJ8NGGj5n7kJaiWwWp9AjC+Yh8rhZY3GtAX8yU28azcLgoRo4oukO87g7zDT" crossorigin="anonymous"></script>
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
  
  
</head>

<body class="has-background-white">
  <nav aria-label="section navigation" class="navbar is-light" role="navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-size-5 has-text-weight-bold" href="https:&#x2F;&#x2F;whatthefox.dev">What the ðŸ¦Š?</a>
        <a aria-expanded="false" aria-label="menu" class="navbar-burger burger" data-target="navMenu" role="button">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div class="navbar-menu" id="navMenu">
        <div class="navbar-end has-text-centered">
          
          
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;">
            Home
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;posts">
            Posts
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;tags">
            Tags
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;categories">
            Categories
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;cv.pdf">
            CV
          </a>
          
          
          
          <a class="navbar-item" id="nav-search" title="Search" data-target="#search-modal">
            <span class="icon">
              <i class="fas fa-search"></i>
            </span>
          </a>
          <a class="navbar-item" id="dark-mode" title="Switch to dark theme">
            <span class="icon">
              <i class="fas fa-adjust"></i>
            </span>
          </a>
        </div>
      </div>
    </div>
  </nav>

  
  

  
<section class="section">
  <div class="container">
    <div class="columns">
      <div class="column is-8 is-offset-2">
        <article class="box">
          <h1 class="title">
            Crabtrap
          </h1>
          <p class="subtitle"></p>
          <div class="columns is-multiline is-gapless">
            <div class="column is-8">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="fas fa-user"></i>
  </span>
  <span>Ian Fox published on</span>
  <span class="icon">
    <i class="far fa-calendar-alt"></i>
  </span>
  <span><time datetime="2024-06-24T20:38:45+02:00">June 24, 2024</time></span>
</span>

            </div>
            <div class="column is-4 has-text-right-desktop">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="far fa-clock"></i>
  </span>
  <span>15 min,</span>
  <span class="icon">
    <i class="fas fa-pencil-alt"></i>
  </span>
  <span>2868 words</span>
</span>

            </div>
            <div class="column">
              
              
<p>
  Categories:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://whatthefox.dev/categories/blog/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-cube"></i>
      </span>
      <span>blog</span>
    </span>
  </a>
  
</p>

              
            </div>
            <div class="column has-text-right-desktop">
              
              
<p>
  Tags:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://whatthefox.dev/tags/computers/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>computers</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://whatthefox.dev/tags/linux/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>linux</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://whatthefox.dev/tags/crabtrap/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>crabtrap</span>
    </span>
  </a>
  
</p>

              
            </div>
          </div>
          <div class="content mt-2">
            <p>I once read a blog post about the capabilities model in WASM, and specifically the idea that you can, when calling another module, give that module some subset of the capabilities you have. The idea being that if I'm, say, calling a function in a compression library, that function doesn't need to be able to talk on the network<sup class="footnote-reference" id="fr-xz-1"><a href="#fn-xz">1</a></sup>. I was looking for a project to do to get back into OS-level programming (my job for the past few years has been very much the opposite of that) and thought it would be fun to try to implement something similar with binaries in Linux. The first part of that project is what this post is about.</p>
<p>If you just want to see the code, it's on <a href="https://github.com/ian-fox/crabtrap">github</a>!</p>
<span id="continue-reading"></span><h2 id="what-are-we-building"><a class="zola-anchor" href="#what-are-we-building" aria-label="Anchor link for: what-are-we-building">ðŸ”—</a>What are we building?</h2>
<p>The core idea is a pretty simple one: <a href="https://www.kernel.org/doc/html/latest/userspace-api/seccomp_filter.html">seccomp-bpf</a> is a system which allows you to restrict which syscalls<sup class="footnote-reference" id="fr-syscalls-1"><a href="#fn-syscalls">2</a></sup> an application can make. It operates at the process level. We can get some more fine-grained information on where syscalls are coming from with tools like <a href="https://strace.io/">strace</a> though; it has a <code>--stack-trace</code> flag which will, when it intercepts a syscall, trace the syscall all the way back up the stack.</p>
<p>We're going to combine these ideas to make a more fine-grained version of a <code>seccomp-bpf</code>-like system. The goal is to make something that will allow us to filter different sets of syscalls based on which code units within the process are making them. It's entirely possible that this has been done already, but because a quick search didn't turn anything up and the primary goal of this is to learn I'm not too concerned with reimplementing things.</p>
<p>The basic goal for our first proof of concept is simple: given a configuration profile and a binary, run the binary and filter syscalls based on what shared<sup class="footnote-reference" id="fr-shared-object-1"><a href="#fn-shared-object">3</a></sup> object they originate from.</p>
<h2 id="nongoals"><a class="zola-anchor" href="#nongoals" aria-label="Anchor link for: nongoals">ðŸ”—</a>Nongoals</h2>
<p>For this first step, there are a whole <em>bunch</em> of things we're not going to worry about:</p>
<ul>
<li>Performance: for a first pass I decided to do a proof of concept fully in userland with <code>ptrace</code>. Since this will involve a lot of context switches we know it's going to be slow, but in future iterations I want to reimplement it with a kernel module and possibly with eBPF, if it proves strong enough.</li>
<li>Shared objects as the unit of code: I think in theory it should be possible to map out where the various parts of a statically compiled dependency end up in your code and filter based on that, but for the first pass we're only going to worry about whether a syscall originates from your binary directly, or goes through one (or more) shared objects on the way.</li>
<li>One architecture: anything dealing with syscalls is going to be architecture dependent. Since I'm doing this mostly as a proof of concept and learning project, I decided to implement it for aarch64<sup class="footnote-reference" id="fr-arm-1"><a href="#fn-arm">4</a></sup>.</li>
<li>Kill on violation: in theory we could fail the banned syscalls by modifying their return values. For now we'll just kill the child instead.</li>
<li>Minimal error handling: for the first pass there's going to be a lot of <code>.expect</code>s.</li>
<li>Small dependency graph: especially for a security-related program we'd like to keep our list of dependencies small. Again, since this is just a proof of concept, not going to worry about it.</li>
<li>We aren't going to worry about redirecting <code>stdin</code>, <code>stdout</code>, or <code>stderr</code><sup class="footnote-reference" id="fr-redirects-1"><a href="#fn-redirects">5</a></sup>.</li>
<li>Ignoring some edge cases: we'll come across some edge cases which will be possible to handle but at the cost of complexity. At least for the first pass we're going to ignore some of those and worry about them another time<sup class="footnote-reference" id="fr-signals-1"><a href="#fn-signals">6</a></sup>.</li>
<li>No grandchildren. For the proof of concept managing one child is enough.</li>
</ul>
<p>I'm also using this as an excuse to write some rust again, which is another thing I haven't used in a while. This also gives us a great pun-based naming opportunity: we're building a jail (or jail-like object at least) in rust, so we can call it "crab trap!"</p>
<h2 id="a-toy-example"><a class="zola-anchor" href="#a-toy-example" aria-label="Anchor link for: a-toy-example">ðŸ”—</a>A toy example</h2>
<p>With those requirements set, let's get into the coding! The code for this post will live <a href="https://github.com/ian-fox/crabtrap">here</a> if you want to follow along.</p>
<p>The first thing we'll need is a toy binary. We'll write a simple wrapper:<sup class="footnote-reference" id="fr-c-quality-1"><a href="#fn-c-quality">7</a></sup></p>
<p><code>printf_wrapper.c</code></p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdio.h</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdarg.h</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">printf_wrapper</span><span>(</span><span style="color:#b48ead;">const char </span><span>*</span><span style="color:#bf616a;">format</span><span>, ...) {
</span><span>    va_list args;
</span><span>    </span><span style="color:#96b5b4;">va_start</span><span>(args, format);
</span><span>    </span><span style="color:#b48ead;">int</span><span> result = </span><span style="color:#96b5b4;">vprintf</span><span>(format, args);
</span><span>    </span><span style="color:#96b5b4;">va_end</span><span>(args);
</span><span>    </span><span style="color:#b48ead;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>And a binary that calls <code>write</code> through both that and just through normal <code>libc</code>:</p>
<p><code>static.c</code></p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdio.h</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">printf_wrapper</span><span>(</span><span style="color:#b48ead;">const char </span><span>*</span><span style="color:#bf616a;">format</span><span>, ...);
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">Hello from printf!</span><span style="color:#96b5b4;">\n</span><span>&quot;);
</span><span>    </span><span style="color:#bf616a;">printf_wrapper</span><span>(&quot;</span><span style="color:#a3be8c;">Hello from printf_wrapper!</span><span style="color:#96b5b4;">\n</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>For fun, we can also make one that loads the library dynamically:</p>
<p><code>dynamic.c</code></p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">stdio.h</span><span>&gt;
</span><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">dlfcn.h</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">void </span><span>*handle = </span><span style="color:#bf616a;">dlopen</span><span>(&quot;</span><span style="color:#a3be8c;">/usr/local/lib/libprintf_wrapper.so</span><span>&quot;, RTLD_LAZY);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!handle) {
</span><span>        </span><span style="color:#96b5b4;">fprintf</span><span>(stderr, &quot;</span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span>&quot;, </span><span style="color:#bf616a;">dlerror</span><span>());
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">int </span><span>(*printf_wrapper)(</span><span style="color:#b48ead;">const char </span><span>*, ...);
</span><span>    *(</span><span style="color:#b48ead;">void </span><span>**) (&amp;printf_wrapper) = </span><span style="color:#bf616a;">dlsym</span><span>(handle, &quot;</span><span style="color:#a3be8c;">printf_wrapper</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">char </span><span>*error = </span><span style="color:#bf616a;">dlerror</span><span>();
</span><span>    </span><span style="color:#b48ead;">if </span><span>(error != </span><span style="color:#d08770;">NULL</span><span>) {
</span><span>        </span><span style="color:#96b5b4;">fprintf</span><span>(stderr, &quot;</span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span>&quot;, error);
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">Hello from printf!</span><span style="color:#96b5b4;">\n</span><span>&quot;);
</span><span>    </span><span style="color:#bf616a;">printf_wrapper</span><span>(&quot;</span><span style="color:#a3be8c;">Hello from printf_wrapper!</span><span style="color:#96b5b4;">\n</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#bf616a;">dlclose</span><span>(handle);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>We'll put it in a container to make sure we have a consistent environment:</p>
<pre data-lang="Dockerfile" style="background-color:#2b303b;color:#c0c5ce;" class="language-Dockerfile "><code class="language-Dockerfile" data-lang="Dockerfile"><span style="color:#65737e;"># Use rust so that it will work with the later environments
</span><span style="color:#b48ead;">FROM</span><span> rust:1
</span><span>
</span><span style="color:#b48ead;">WORKDIR </span><span>/crabtrap_test
</span><span style="color:#b48ead;">ENV </span><span>LD_LIBRARY_PATH=/usr/local/lib
</span><span style="color:#b48ead;">COPY</span><span> sample_program/printf_wrapper.c \
</span><span>    sample_program/dynamic.c \
</span><span>    sample_program/static.c \
</span><span>    ./
</span><span style="color:#b48ead;">RUN </span><span>gcc -c -o libprintf_wrapper.o printf_wrapper.c \
</span><span> &amp;&amp; ar rcs libprintf_wrapper.a libprintf_wrapper.o \
</span><span> &amp;&amp; gcc -shared -fPIC -o /usr/local/lib/libprintf_wrapper.so printf_wrapper.c \
</span><span> &amp;&amp; gcc -o dynamic dynamic.c -ldl \
</span><span> &amp;&amp; gcc -o static static.c -lprintf_wrapper \
</span><span> &amp;&amp; gcc -static-pie -o all-in-one static.c -L. -l:libprintf_wrapper.a
</span></code></pre>
<p>Now we've built three versions of our binary: two that load the shared object, and one that builds <code>libprintf_wrapper</code> in statically just as a point of comparison. Let's build make sure everything works:</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">$</span><span> ./static
</span><span style="color:#bf616a;">Hello</span><span> from printf!
</span><span style="color:#bf616a;">Hello</span><span> from printf_wrapper!
</span><span style="color:#bf616a;">$</span><span> ./dynamic
</span><span style="color:#bf616a;">Hello</span><span> from printf!
</span><span style="color:#bf616a;">Hello</span><span> from printf_wrapper!
</span><span style="color:#bf616a;">$</span><span> ./all-in-one 
</span><span style="color:#bf616a;">Hello</span><span> from printf!
</span><span style="color:#bf616a;">Hello</span><span> from printf_wrapper!
</span></code></pre>
<p>Perfect! This code is at the <a href="https://github.com/ian-fox/crabtrap/releases/tag/walkthrough-0"><code>walkthrough-0</code></a> tag in the repository.</p>
<h2 id="interface-and-tests"><a class="zola-anchor" href="#interface-and-tests" aria-label="Anchor link for: interface-and-tests">ðŸ”—</a>Interface and tests</h2>
<p>We have one more thing to do before we get into the implementation: let's set up our desired interface and some tests. For the input we'll need some config to tell us which syscalls should be allowed or blocked (omitting the <code>derive</code>s and <code>use</code>s for brevity):</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>ConfigEntry {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">allow</span><span>: Option&lt;BTreeSet&lt;Sysno&gt;&gt;,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">block</span><span>: Option&lt;BTreeSet&lt;Sysno&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">pub struct </span><span>Config {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">shared_objects</span><span>: BTreeMap&lt;String, ConfigEntry&gt;,
</span><span>}
</span></code></pre>
<p>And for the output we'll want to get the process's standard out and error, and whether it exited normally or we killed it:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub enum </span><span>ChildExit {
</span><span>    Exited(</span><span style="color:#b48ead;">i32</span><span>),
</span><span>    IllegalSyscall(Sysno, String),
</span><span>}
</span></code></pre>
<p>Finally, the <code>execute</code> function itself:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">execute</span><span>(</span><span style="color:#bf616a;">_path</span><span>: &amp;CStr, </span><span style="color:#bf616a;">_args</span><span>: &amp;[&amp;CStr], </span><span style="color:#bf616a;">_env</span><span>: &amp;[&amp;CStr], </span><span style="color:#bf616a;">_config</span><span>: &amp;Config) -&gt; ChildExit {
</span><span>    todo!();
</span><span>}
</span></code></pre>
<p>The tests are pretty simple, we have one case where everything should go as normal (for now we'll fail open if a syscall isn't explicitly denied), and one where the child should get partway through before being killed:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_ok</span><span>() {
</span><span>    </span><span style="color:#b48ead;">for</span><span> bin in [&quot;</span><span style="color:#a3be8c;">static</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dynamic</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">all-in-one</span><span>&quot;] {
</span><span>        assert_eq!(
</span><span>            crabtrap::execute(
</span><span>                &amp;CString::new(format!(&quot;</span><span style="color:#a3be8c;">/usr/local/bin/</span><span style="color:#d08770;">{}</span><span>&quot;, bin)).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>                &amp;[],
</span><span>                &amp;[&amp;CString::new(&quot;</span><span style="color:#a3be8c;">LD_LIBRARY_PATH=/usr/local/lib</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>()],
</span><span>                &amp;Config {
</span><span>                    shared_objects: BTreeMap::new(),
</span><span>                },
</span><span>            ),
</span><span>            ChildExit::Exited(</span><span style="color:#d08770;">0</span><span>),
</span><span>        );
</span><span>    }
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test_blocked</span><span>() {
</span><span>    </span><span style="color:#b48ead;">for</span><span> bin in [&quot;</span><span style="color:#a3be8c;">static</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">dynamic</span><span>&quot;] {
</span><span>        assert_eq!(
</span><span>            crabtrap::execute(
</span><span>                &amp;CString::new(format!(&quot;</span><span style="color:#a3be8c;">/usr/local/bin/</span><span style="color:#d08770;">{}</span><span>&quot;, bin)).</span><span style="color:#96b5b4;">unwrap</span><span>(),
</span><span>                &amp;[],
</span><span>                &amp;[&amp;CString::new(&quot;</span><span style="color:#a3be8c;">LD_LIBRARY_PATH=/usr/local/lib</span><span>&quot;).</span><span style="color:#96b5b4;">unwrap</span><span>()],
</span><span>                &amp;Config {
</span><span>                    shared_objects: BTreeMap::from([(
</span><span>                        &quot;</span><span style="color:#a3be8c;">libprintf_wrapper.so</span><span>&quot;.</span><span style="color:#96b5b4;">into</span><span>(),
</span><span>                        ConfigEntry {
</span><span>                            allow: None,
</span><span>                            block: Some(BTreeSet::from([Sysno::write])),
</span><span>                        }
</span><span>                    )]),
</span><span>                },
</span><span>            ),
</span><span>            ChildExit::IllegalSyscall(Sysno::write, &quot;</span><span style="color:#a3be8c;">libprintf_wrapper.so</span><span>&quot;.</span><span style="color:#96b5b4;">into</span><span>()),
</span><span>        );
</span><span>    }
</span><span>}
</span></code></pre>
<p>Running <code>cargo test</code> gives us the output we expect: a panic at the <code>todo!()</code>.</p>
<h2 id="ptrace"><a class="zola-anchor" href="#ptrace" aria-label="Anchor link for: ptrace">ðŸ”—</a><code>ptrace</code></h2>
<p>For the proof of concept we're going use a tool called <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html"><code>ptrace</code></a>. <code>ptrace</code> is a piece of Linux which is used by debuggers to allow them to monitor (and change) the execution of another process. A very high-level overview of how it works (or at least how we'll be using it) is this:</p>
<ul>
<li>In the child, we tell <code>ptrace</code> that we are expecting somebody to watch ("trace") us. The child will pause after doing this.</li>
<li>In the parent, we give <code>ptrace</code> some configuration to tell it how we want it to work.</li>
<li>In the parent, we tell <code>ptrace</code> to continue the execution of the child until the next time the child tries to make a syscall.</li>
<li>When the child makes a syscall, the OS will pause it and wake our parent up to see what the parent wants to do about it.</li>
<li>In the parent, we can look at information about what state the child is in and what syscall it's trying to make, and then either tell <code>ptrace</code> to continue until the next syscall again, or kill the child.</li>
</ul>
<p>By continuing this loop the child will keep executing, but every time it tries to do something the OS will pause and check with our parent process first. Eventually the child might call exit, and we can see that in the parent process as well and stop the loop.</p>
<h2 id="running-the-child-process"><a class="zola-anchor" href="#running-the-child-process" aria-label="Anchor link for: running-the-child-process">ðŸ”—</a>Running the child process</h2>
<p>Before we even start worrying about allowing or blocking syscalls, let's make sure we can execute a child process under <code>ptrace</code>. We'll start by forking<sup class="footnote-reference" id="fr-forking-1"><a href="#fn-forking">8</a></sup>:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">execute</span><span>(</span><span style="color:#bf616a;">path</span><span>: &amp;CStr, </span><span style="color:#bf616a;">args</span><span>: &amp;[&amp;CStr], </span><span style="color:#bf616a;">env</span><span>: &amp;[&amp;CStr], </span><span style="color:#bf616a;">config</span><span>: &amp;Config) -&gt; ChildExit {
</span><span>    </span><span style="color:#b48ead;">match unsafe </span><span>{ </span><span style="color:#96b5b4;">fork</span><span>() } {
</span><span>        Ok(ForkResult::Child) =&gt; </span><span style="color:#96b5b4;">child</span><span>(path, args, env),
</span><span>        Ok(ForkResult::Parent { child, .. }) =&gt; </span><span style="color:#96b5b4;">parent</span><span>(child, config),
</span><span>        Err(errno) =&gt; panic!(&quot;</span><span style="color:#a3be8c;">failed to fork: {}</span><span>&quot;, errno),
</span><span>    }
</span><span>}
</span></code></pre>
<p>In the child we'll call <code>traceme</code> to wait for the parent, and then <code>execve</code> into our new life:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">child</span><span>(</span><span style="color:#bf616a;">path</span><span>: &amp;CStr, </span><span style="color:#bf616a;">args</span><span>: &amp;[&amp;CStr], </span><span style="color:#bf616a;">env</span><span>: &amp;[&amp;CStr]) -&gt; ! {
</span><span>    </span><span style="color:#65737e;">// Unsafe to use `println!` (or `unwrap`) here. See https://docs.rs/nix/latest/nix/unistd/fn.fork.html#safety
</span><span>    </span><span style="color:#65737e;">// Since we&#39;re not handling errors anyway, panics should be fine for now.
</span><span>
</span><span>    </span><span style="color:#96b5b4;">traceme</span><span>().</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">error calling traceme</span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">execve</span><span>(path, args, env).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">error calling execve</span><span>&quot;);
</span><span>    unreachable!();
</span><span>}
</span></code></pre>
<p>Meanwhile in the parent we wait for the child, set up our ptrace options, and then enter the loop where we tell the child to continue until the next syscall or until we see it exit:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">parent</span><span>(</span><span style="color:#bf616a;">child</span><span>: Pid, </span><span style="color:#bf616a;">_config</span><span>: &amp;Config) -&gt; ChildExit {
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Continuing execution in parent process, new child has pid: </span><span style="color:#d08770;">{child}</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#65737e;">// Wait for the stop from the first exec
</span><span>    </span><span style="color:#96b5b4;">waitpid</span><span>(child, None).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to waitpid</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#96b5b4;">setoptions</span><span>(
</span><span>        child,
</span><span>        Options::</span><span style="color:#d08770;">PTRACE_O_EXITKILL</span><span>.</span><span style="color:#96b5b4;">union</span><span>(Options::</span><span style="color:#d08770;">PTRACE_O_TRACESYSGOOD</span><span>),
</span><span>    )
</span><span>    .</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to set ptrace options</span><span>&quot;);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Starting to watch child...</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        </span><span style="color:#96b5b4;">syscall</span><span>(child, None).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to restart child</span><span>&quot;);
</span><span>        </span><span style="color:#b48ead;">match </span><span style="color:#96b5b4;">waitpid</span><span>(child, None).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to get status from waitpid</span><span>&quot;) {
</span><span>            WaitStatus::Exited(_, code) =&gt; {
</span><span>                </span><span style="color:#b48ead;">return </span><span>ChildExit::Exited(code);
</span><span>            }
</span><span>            WaitStatus::PtraceSyscall(_pid) =&gt; {
</span><span>                </span><span style="color:#65737e;">// This is where the syscall handling logic will go.
</span><span>            }
</span><span>            status =&gt; panic!(&quot;</span><span style="color:#a3be8c;">unexpected child process status {status:?}</span><span>&quot;),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>And that's it! After running <code>cargo test</code> again we get the results we expected on the first try<sup class="footnote-reference" id="fr-first-try-1"><a href="#fn-first-try">9</a></sup>! <code>test_ok</code> passes, and <code>test_blocked</code> fails because we haven't implemented that part yet. This code is at the tag <a href="https://github.com/ian-fox/crabtrap/releases/tag/walkthrough-1"><code>walkthrough-1</code></a> in the git repo.</p>
<h2 id="getting-a-stack-trace"><a class="zola-anchor" href="#getting-a-stack-trace" aria-label="Anchor link for: getting-a-stack-trace">ðŸ”—</a>Getting a stack trace</h2>
<p>Now we're starting to get into the fun stuff! Our <code>waitpid</code> call will return with a <code>WaitStatus::PtraceSyscall(pid)</code> whenever our child enters or exits a syscall<sup class="footnote-reference" id="fr-enter-exit-1"><a href="#fn-enter-exit">10</a></sup>. This is one of those things that if we were making a real system we would care about only checking on the enter side (in most cases), but for a proof of concept we'll just take the performance hit of checking every syscall twice.</p>
<p>We'll move the syscall handling itself out into a function. The first thing we'll want to do is grab the registers so that we can tell what syscall is happening and where the child is in its execution:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">handle_syscall</span><span>(</span><span style="color:#bf616a;">pid</span><span>: Pid, </span><span style="color:#bf616a;">_config</span><span>: &amp;Config) {
</span><span>    </span><span style="color:#b48ead;">let</span><span> regs = </span><span style="color:#96b5b4;">getregs</span><span>(pid).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Could not get registers</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> syscall = Sysno::from(regs.regs[</span><span style="color:#d08770;">8</span><span>] as </span><span style="color:#b48ead;">u32</span><span>);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Syscall: </span><span style="color:#d08770;">{syscall}</span><span>&quot;);
</span></code></pre>
<p>Now we can start walking up the stack. If we look at the <a href="https://github.com/ARM-software/abi-aa/blob/2a70c42d62e9c3eb5887fa50b71257f20daca6f9/aapcs64/aapcs64.rst#646the-frame-pointer">ARM docs</a> we can see that the previous pc<sup class="footnote-reference" id="fr-pc-1"><a href="#fn-pc">11</a></sup> is held in the link register (<code>r30</code>) and the pointer to the first stack frame is in <code>r29</code><sup class="footnote-reference" id="fr-verify-previous-pc-1"><a href="#fn-verify-previous-pc">12</a></sup>. The docs also tells us that at each stack frame we'll have a frame pointer which points to the previous stack frame (or 0 if we're at the base).</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b48ead;">let mut</span><span> frame_pointer: </span><span style="color:#b48ead;">u64 </span><span>= regs.regs[</span><span style="color:#d08770;">29</span><span>];
</span><span>    println!(
</span><span>        &quot;</span><span style="color:#a3be8c;">Initial pc: </span><span style="color:#d08770;">{pc:x}</span><span style="color:#a3be8c;">, lr: </span><span style="color:#d08770;">{lr:x}</span><span style="color:#a3be8c;">, fp: </span><span style="color:#d08770;">{frame_pointer:x}</span><span>&quot;,
</span><span>        pc = regs.pc,
</span><span>        lr = regs.regs[</span><span style="color:#d08770;">30</span><span>]
</span><span>    );
</span></code></pre>
<p>Finally, the docs tells us that just above the frame pointer is the saved value of the previous link register. Now we can print that and then walk our way up by following the frame pointers until we hit the base of the stack:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b48ead;">let mut</span><span> saved_lr;
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        </span><span style="color:#b48ead;">if</span><span> frame_pointer == </span><span style="color:#d08770;">0 </span><span>{
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        }
</span><span>
</span><span>        saved_lr =
</span><span>            </span><span style="color:#96b5b4;">read</span><span>(pid, (frame_pointer + </span><span style="color:#d08770;">8</span><span>) as AddressType).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to read saved lr</span><span>&quot;) as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">saved_lr: </span><span style="color:#d08770;">{saved_lr:x}</span><span style="color:#a3be8c;">, frame pointer: </span><span style="color:#d08770;">{frame_pointer:x}</span><span>&quot;);
</span><span>
</span><span>        frame_pointer =
</span><span>            </span><span style="color:#96b5b4;">read</span><span>(pid, frame_pointer as AddressType).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to read frame pointer</span><span>&quot;) as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Bottom of stack.</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>Running this we do get lots of nice stack traces! Next up we need to map the pc locations to code units. This code is at the tag <a href="https://github.com/ian-fox/crabtrap/releases/tag/walkthrough-2"><code>walkthrough-2</code></a>.</p>
<h2 id="mapping-to-shared-objects"><a class="zola-anchor" href="#mapping-to-shared-objects" aria-label="Anchor link for: mapping-to-shared-objects">ðŸ”—</a>Mapping to shared objects</h2>
<p>Our goal is in sight! The last thing we need to do is map our series of program counters back to the files they come from, and then use that to make a decision about whether to allow the syscall or not. We can get this information by looking in the <a href="https://www.man7.org/linux/man-pages/man5/proc_pid_maps.5.html">proc filesystem</a>. For instance, when I run <code>cat /proc/self/maps</code> I get the following:</p>
<pre data-lang="plain" style="background-color:#2b303b;color:#c0c5ce;" class="language-plain "><code class="language-plain" data-lang="plain"><span>aaaad82c0000-aaaad82c9000 r-xp 00000000 fe:01 188725                     /usr/bin/cat
</span><span>aaaad82df000-aaaad82e0000 r--p 0000f000 fe:01 188725                     /usr/bin/cat
</span><span>aaaad82e0000-aaaad82e1000 rw-p 00010000 fe:01 188725                     /usr/bin/cat
</span><span>aaab05aba000-aaab05adb000 rw-p 00000000 00:00 0                          [heap]
</span><span>ffff9e0ce000-ffff9e0f0000 rw-p 00000000 00:00 0 
</span><span>ffff9e0f0000-ffff9e277000 r-xp 00000000 fe:01 319964                     /usr/lib/aarch64-linux-gnu/libc.so.6
</span><span>ffff9e277000-ffff9e28c000 ---p 00187000 fe:01 319964                     /usr/lib/aarch64-linux-gnu/libc.so.6
</span><span>ffff9e28c000-ffff9e290000 r--p 0018c000 fe:01 319964                     /usr/lib/aarch64-linux-gnu/libc.so.6
</span><span>ffff9e290000-ffff9e292000 rw-p 00190000 fe:01 319964                     /usr/lib/aarch64-linux-gnu/libc.so.6
</span><span>ffff9e292000-ffff9e29f000 rw-p 00000000 00:00 0 
</span><span>ffff9e2aa000-ffff9e2d0000 r-xp 00000000 fe:01 319946                     /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1
</span><span>ffff9e2db000-ffff9e2dd000 rw-p 00000000 00:00 0 
</span><span>ffff9e2e3000-ffff9e2e5000 rw-p 00000000 00:00 0 
</span><span>ffff9e2e5000-ffff9e2e7000 r--p 00000000 00:00 0                          [vvar]
</span><span>ffff9e2e7000-ffff9e2e8000 r-xp 00000000 00:00 0                          [vdso]
</span><span>ffff9e2e8000-ffff9e2ea000 r--p 0002e000 fe:01 319946                     /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1
</span><span>ffff9e2ea000-ffff9e2ec000 rw-p 00030000 fe:01 319946                     /usr/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1
</span><span>ffffdaf66000-ffffdaf87000 rw-p 00000000 00:00 0                          [stack]
</span></code></pre>
<p>This tells us which regions of memory are mapped to which files (as well as some other locations like the stack). By replacing <code>self</code> in the path with the PID of our child process, we can see the mapping for our child. For our purposes, what we care about are the first and second numbers which represent the location in memory that particular mapping lives at, and the final component which is (at least for the shared objects we care about) the path of the underlying file<sup class="footnote-reference" id="fr-path-ambiguity-1"><a href="#fn-path-ambiguity">13</a></sup>.</p>
<p>Let's define some structs to help us with this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>Region {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">start</span><span>: </span><span style="color:#b48ead;">u64</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">end</span><span>: </span><span style="color:#b48ead;">u64</span><span>,
</span><span>    </span><span style="color:#bf616a;">path</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">pub struct </span><span>MemoryMap {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">files</span><span>: Vec&lt;Region&gt;,
</span><span>}
</span></code></pre>
<p>This post is getting long as it is, so we'll skip the details of those. They're in the git repo in <code>map.rs</code> if you want to look at them in more detail. The important part is that <code>MemoryMap</code> exposes a function <code>lookup&lt;'a&gt;(&amp;'a self, addr: u64) -&gt; Option&lt;&amp;'a str&gt;</code> which will let us move from a program counter location to a path, if it's in our mapping.</p>
<p>We can create the map when the child gets <code>exec</code>ed into, and then pass it to our syscall handler:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">execute</span><span>(...) {
</span><span>    ...
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> memory_map = MemoryMap::from_pid(child_id);
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Starting to watch child...</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        ...
</span><span>        WaitStatus::PtraceSyscall(pid) =&gt; {
</span><span>            </span><span style="color:#96b5b4;">handle_syscall</span><span>(pid, config, &amp;</span><span style="color:#b48ead;">mut</span><span> memory_map);
</span><span>        }
</span><span>    }
</span></code></pre>
<p>We're passing it in as mutable because if we see a syscall that might modify the process memory we'll want to rebuild the map[^rebuild]. Let's handle that part first:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">handle_syscall</span><span>(</span><span style="color:#bf616a;">pid</span><span>: Pid, </span><span style="color:#bf616a;">config</span><span>: &amp;Config, </span><span style="color:#bf616a;">map</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> MemoryMap) {
</span><span>    </span><span style="color:#b48ead;">let</span><span> regs = </span><span style="color:#96b5b4;">getregs</span><span>(pid).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Could not get registers</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> syscall = Sysno::from(regs.regs[</span><span style="color:#d08770;">8</span><span>] as </span><span style="color:#b48ead;">u32</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// I don&#39;t have an exhaustive knowledge of which syscalls might affect memory.
</span><span>    </span><span style="color:#65737e;">// For a real project I&#39;d do more research or set up some tests to see if I&#39;d missed any.
</span><span>    </span><span style="color:#b48ead;">if </span><span>BTreeSet::from([
</span><span>        Sysno::execve,
</span><span>        Sysno::execveat,
</span><span>        Sysno::clone,
</span><span>        Sysno::mmap,
</span><span>        Sysno::munmap,
</span><span>        Sysno::mremap,
</span><span>    ])
</span><span>    .</span><span style="color:#96b5b4;">contains</span><span>(&amp;syscall)
</span><span>    {
</span><span>        *map = MemoryMap::from_pid(pid);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> addr in [regs.pc, regs.regs[</span><span style="color:#d08770;">30</span><span>]] {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(loc) = map.</span><span style="color:#96b5b4;">lookup</span><span>(addr) {
</span><span>            println!(&quot;</span><span style="color:#d08770;">{syscall}</span><span style="color:#a3be8c;"> from </span><span style="color:#d08770;">{addr:x}</span><span style="color:#a3be8c;"> in </span><span style="color:#d08770;">{loc}</span><span>&quot;);
</span><span>        }
</span><span>    }
</span><span>    
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> frame_pointer: </span><span style="color:#b48ead;">u64 </span><span>= regs.regs[</span><span style="color:#d08770;">29</span><span>];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> saved_lr;
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        </span><span style="color:#b48ead;">if</span><span> frame_pointer == </span><span style="color:#d08770;">0 </span><span>{
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        }
</span><span>
</span><span>        saved_lr =
</span><span>            </span><span style="color:#96b5b4;">read</span><span>(pid, (frame_pointer + </span><span style="color:#d08770;">8</span><span>) as AddressType).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to read saved lr</span><span>&quot;) as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(loc) = map.</span><span style="color:#96b5b4;">lookup</span><span>(saved_lr) {
</span><span>            println!(&quot;</span><span style="color:#d08770;">{syscall}</span><span style="color:#a3be8c;"> from </span><span style="color:#d08770;">{saved_lr:x}</span><span style="color:#a3be8c;"> in </span><span style="color:#d08770;">{loc}</span><span>&quot;);
</span><span>        }
</span><span>
</span><span>        frame_pointer =
</span><span>            </span><span style="color:#96b5b4;">read</span><span>(pid, frame_pointer as AddressType).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to read frame pointer</span><span>&quot;) as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Reached bottom of stack.</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>Finally we have all the information we need!</p>
<h2 id="blocking-syscalls"><a class="zola-anchor" href="#blocking-syscalls" aria-label="Anchor link for: blocking-syscalls">ðŸ”—</a>Blocking syscalls</h2>
<p>The final piece we need is to walk up the stack until we see a shared object we recognize that has a matching allow or deny rule for the current syscall, or we hit the base. We'll modify <code>Config</code> to handle this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub enum </span><span>Check {
</span><span>    Allowed,
</span><span>    Blocked,
</span><span>    Unknown,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Config {
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">check</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">loc</span><span>: &amp;</span><span style="color:#b48ead;">str</span><span>, </span><span style="color:#bf616a;">syscall</span><span>: Sysno) -&gt; Check {
</span><span>        </span><span style="color:#b48ead;">match </span><span style="color:#bf616a;">self</span><span>.shared_objects.</span><span style="color:#96b5b4;">get</span><span>(loc) {
</span><span>            Some(entry) =&gt; {
</span><span>                </span><span style="color:#b48ead;">if</span><span> entry
</span><span>                    .allow
</span><span>                    .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>                    .</span><span style="color:#96b5b4;">is_some_and</span><span>(|</span><span style="color:#bf616a;">allowed</span><span>| allowed.</span><span style="color:#96b5b4;">contains</span><span>(&amp;syscall))
</span><span>                {
</span><span>                    </span><span style="color:#b48ead;">return </span><span>Check::Allowed;
</span><span>                } </span><span style="color:#b48ead;">else if</span><span> entry
</span><span>                    .block
</span><span>                    .</span><span style="color:#96b5b4;">as_ref</span><span>()
</span><span>                    .</span><span style="color:#96b5b4;">is_some_and</span><span>(|</span><span style="color:#bf616a;">blocked</span><span>| blocked.</span><span style="color:#96b5b4;">contains</span><span>(&amp;syscall))
</span><span>                {
</span><span>                    </span><span style="color:#b48ead;">return </span><span>Check::Blocked;
</span><span>                } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                    </span><span style="color:#b48ead;">return </span><span>Check::Unknown;
</span><span>                }
</span><span>            }
</span><span>            None =&gt; Check::Unknown,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Putting everything together, our <code>handle_syscall</code> function now looks like this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">handle_syscall</span><span>(</span><span style="color:#bf616a;">pid</span><span>: Pid, </span><span style="color:#bf616a;">config</span><span>: &amp;Config, </span><span style="color:#bf616a;">map</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> MemoryMap) -&gt; Option&lt;ChildExit&gt; {
</span><span>    </span><span style="color:#b48ead;">let</span><span> regs = </span><span style="color:#96b5b4;">getregs</span><span>(pid).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">Could not get registers</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> syscall = Sysno::from(regs.regs[</span><span style="color:#d08770;">8</span><span>] as </span><span style="color:#b48ead;">u32</span><span>);
</span><span>
</span><span>    </span><span style="color:#65737e;">// I don&#39;t have an exhaustive knowledge of which syscalls might affect memory.
</span><span>    </span><span style="color:#65737e;">// For a real project I&#39;d do more research or set up some tests to see if I&#39;d missed any.
</span><span>    </span><span style="color:#b48ead;">if </span><span>BTreeSet::from([
</span><span>        Sysno::execve,
</span><span>        Sysno::execveat,
</span><span>        Sysno::clone,
</span><span>        Sysno::mmap,
</span><span>        Sysno::munmap,
</span><span>        Sysno::mremap,
</span><span>    ])
</span><span>    .</span><span style="color:#96b5b4;">contains</span><span>(&amp;syscall)
</span><span>    {
</span><span>        *map = MemoryMap::from_pid(pid);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> addr in [regs.pc, regs.regs[</span><span style="color:#d08770;">30</span><span>]] {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(loc) = map.</span><span style="color:#96b5b4;">lookup</span><span>(addr) {
</span><span>            </span><span style="color:#b48ead;">match</span><span> config.</span><span style="color:#96b5b4;">check</span><span>(loc, syscall) {
</span><span>                Check::Allowed =&gt; </span><span style="color:#b48ead;">return </span><span>None,
</span><span>                Check::Blocked =&gt; </span><span style="color:#b48ead;">return </span><span>Some(ChildExit::IllegalSyscall(syscall, loc.</span><span style="color:#96b5b4;">to_string</span><span>())),
</span><span>                Check::Unknown =&gt; {}
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> frame_pointer: </span><span style="color:#b48ead;">u64 </span><span>= regs.regs[</span><span style="color:#d08770;">29</span><span>];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> saved_lr;
</span><span>    </span><span style="color:#b48ead;">loop </span><span>{
</span><span>        </span><span style="color:#b48ead;">if</span><span> frame_pointer == </span><span style="color:#d08770;">0 </span><span>{
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        }
</span><span>
</span><span>        saved_lr =
</span><span>            </span><span style="color:#96b5b4;">read</span><span>(pid, (frame_pointer + </span><span style="color:#d08770;">8</span><span>) as AddressType).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to read saved lr</span><span>&quot;) as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Some(loc) = map.</span><span style="color:#96b5b4;">lookup</span><span>(saved_lr) {
</span><span>            </span><span style="color:#b48ead;">match</span><span> config.</span><span style="color:#96b5b4;">check</span><span>(loc, syscall) {
</span><span>                Check::Allowed =&gt; </span><span style="color:#b48ead;">return </span><span>None,
</span><span>                Check::Blocked =&gt; </span><span style="color:#b48ead;">return </span><span>Some(ChildExit::IllegalSyscall(syscall, loc.</span><span style="color:#96b5b4;">to_string</span><span>())),
</span><span>                Check::Unknown =&gt; {}
</span><span>            }
</span><span>        }
</span><span>
</span><span>        frame_pointer =
</span><span>            </span><span style="color:#96b5b4;">read</span><span>(pid, frame_pointer as AddressType).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to read frame pointer</span><span>&quot;) as </span><span style="color:#b48ead;">u64</span><span>;
</span><span>    }
</span><span>
</span><span>    None
</span><span>}
</span></code></pre>
<p>And if we run the tests we can see that with no restrictions both messages get printed and the child exits 0, but when we restrict the <code>write</code> syscall coming from <code>libprintf_wrapper.so</code> we only see the "Hello from printf!" before the child process gets terminated! Fantastic!</p>
<pre data-lang="sh" style="background-color:#2b303b;color:#c0c5ce;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#bf616a;">$</span><span> ./target/debug/crabtrap /usr/local/bin/dynamic config.yaml
</span><span style="color:#bf616a;">Continuing</span><span> execution in parent process, new child has pid: 11
</span><span style="color:#bf616a;">Starting</span><span> to watch child...
</span><span style="color:#bf616a;">Hello</span><span> from printf!
</span><span style="color:#bf616a;">IllegalSyscall</span><span>(write, &quot;</span><span style="color:#a3be8c;">/usr/local/lib/libprintf_wrapper.so</span><span>&quot;)
</span></code></pre>
<p>This code is at <a href="https://github.com/ian-fox/crabtrap/releases/tag/walkthrough-3"><code>walkthrough-3</code></a>.</p>
<h2 id="next-steps"><a class="zola-anchor" href="#next-steps" aria-label="Anchor link for: next-steps">ðŸ”—</a>Next steps</h2>
<p>We've shown that the concept works. I think there are a few possible directions to go next, all of them exciting:</p>
<ul>
<li>Properly implement the signals, grandchildren, a proper command line interface, all the edge cases, etc. and then find a real example for some benchmarking to see exactly how bad the slowdown is with the naive implementation</li>
<li>Start diving into one of the other implementations (investigate if some userland bookkeeping along with eBPF for the actual enforcement is possible, or a full-on kernel module)</li>
<li>Start trying to map code units smaller than shared objects for dependencies that are statically compiled into a program</li>
</ul>
<p>I'm not sure which I'll tackle first, if you have any thoughts (or have just found this interesting) feel free to drop me an <a href="mailto:ian@whatthefox.dev">email</a> any time!</p>
<footer class="footnotes">
<ol class="footnotes-list">
<li id="fn-xz">
<p>I looked a bit into how the xz backdoor worked and I'm not 100% sure that something as simple as this would have stopped it. Later on once I have a working sandbox I'll see if I can test that! <a href="#fr-xz-1">â†©</a></p>
</li>
<li id="fn-syscalls">
<p>Whenever any program running on your computer wants to do something like read a file, open a network connection, it has to ask the operating system for permission. It does this by telling the OS what it wants to do, and then giving control to the OS. The OS will (after checking things like that the program is allowed to do what it's trying to do) carry out the request, and then return control to the program. <a href="#fr-syscalls-1">â†©</a></p>
</li>
<li id="fn-shared-object">
<p>One method of calling third party code is to use shared objects. We tell our code that we expect there to be a function with a certain name living in a certain shared object file, and then that file will be loaded into our process memory so that we can call the function. This can (very roughly) tell us where a piece of code came from. <a href="#fr-shared-object-1">â†©</a></p>
</li>
<li id="fn-arm">
<p>This is both because I'm on an ARM laptop, and because I've dealt with x86 assembly and calling conventions before but never ARM. This seemed as good a time as any to jump in! <a href="#fr-arm-1">â†©</a></p>
</li>
<li id="fn-redirects">
<p>Originally I was using <code>process::Command</code>, which would have given me this for free. Unfortunately it seems like somewhere inside <code>process::Command</code> is an extra call to <code>clone</code> that I couldn't quite track, so we're going to roll our own for now. In a real application we'd maybe try to do some more debugging on that to get the nicer interface. <a href="#fr-redirects-1">â†©</a></p>
</li>
<li id="fn-signals">
<p>The main one is signal handling. It seems like signals can be tricky with <code>ptrace</code>, and while I'm sure it's possible to handle nicely (debuggers must have some way of dealing with it) it's not particularly relevant to the concept we want to prove here. <a href="#fr-signals-1">â†©</a></p>
</li>
<li id="fn-c-quality">
<p>I've never written production C code before. I'm sure there are all sorts of best practices that this isn't following. <a href="#fr-c-quality-1">â†©</a></p>
</li>
<li id="fn-forking">
<p>Clone is probably better practice, but this is a toy example for now and I like the word fork. <a href="#fr-forking-1">â†©</a></p>
</li>
<li id="fn-first-try">
<p>Not even close, but I've spared you all the silly mistakes. <a href="#fr-first-try-1">â†©</a></p>
</li>
<li id="fn-enter-exit">
<p>From the <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html"><code>ptrace</code> man page</a>: "Syscall-enter-stop and syscall-exit-stop are indistinguishable from each other by the tracer. The tracer needs to keep track of the sequence of ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-stop or vice versa. In general, a syscall-enter-stop is always followed by syscall-exit-stop, PTRACE_EVENT stop, or the tracee's death; no other kinds of ptrace-stop can occur in between. However, note that seccomp stops (see below) can cause syscall-exit-stops, without preceding syscall-entry-stops. If seccomp is in use, care needs to be taken not to misinterpret such stops as syscall-entry-stops." <a href="#fr-enter-exit-1">â†©</a></p>
</li>
<li id="fn-pc">
<p>"program counter" - this is like a bookmark telling the child process what step of its instructions it's currently executing. It's how we'll be able to tell which piece of code is trying to make the syscall. <a href="#fr-pc-1">â†©</a></p>
</li>
<li id="fn-verify-previous-pc">
<p>Just to verify, we can also check that the previous pc from <code>r30</code> is the same as the link register when we go down one frame on the stack. <a href="#fr-verify-previous-pc-1">â†©</a></p>
</li>
<li id="fn-path-ambiguity">
<p>As the doc points out, the pathname is potentially ambiguous when newlines are present or the underlying file has been deleted. I'm sure we could disambiguate this by looking at the inode instead, but that's beyond the scope of this proof of concept.
[^rebuild] Unfortunately, because the "files" in the <code>/proc/</code> filesystem aren't actually files, we can't just subscribe to get notified and rebuild the map any time it changes. This is a case where we actually would want to do the work at the syscall return, since the map wouldn't be updated until that point. <a href="#fr-path-ambiguity-1">â†©</a></p>
</li>
</ol>
</footer>

          </div>
        </article>
      </div>
      
    </div>
  </div>
</section>


  
  <section class="modal" id="search-modal">
    <div class="modal-background"></div>
    <div class="modal-card">
      <header class="modal-card-head">
        <p class="modal-card-title">Search</p>
      </header>
      <section class="modal-card-body">
        <div class="field mb-2">
          <div class="control">
            <input class="input" id="search" placeholder="Search this website." type="search" />
          </div>
        </div>
        <div class="search-results">
          <div class="search-results__items"></div>
        </div>
      </section>
    </div>
    <button aria-label="close" class="modal-close is-large"></button>
  </section>
  


  

<section class="section">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <nav class="level">
              
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;posts&#x2F;fast-forwarding-videos&#x2F;">
              <span class="icon mr-2">
                <i class="fas fa-arrow-circle-left"></i>
              </span>
              Fast-forwarding Videos with Javascript
            </a>
          </div>
           
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;whatthefox.dev&#x2F;posts&#x2F;crabtrap-2&#x2F;">
              Crabtrap Part 2: Electric Boogaloo<span class="icon ml-2">
                <i class="fas fa-arrow-circle-right"></i>
              </span>
            </a>
          </div>
          
        </nav>
      </div>
    </div>
  </div>
</section>



  



  
  <footer class="footer py-4">
    <div class="content has-text-centered">
      <p>
        Built with
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-code"></i>
          </span>
          <span>code</span>
        </span>
        and
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-heart"></i>
          </span>
          <span>love</span>
        </span>
      </p>
      <p>
        Powered by
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-power-off"></i>
          </span>
          <span>zola</span>
        </span>
      </p>
    </div>
  </footer>
  

  
  
  
  
  <script src="https://whatthefox.dev/elasticlunr.min.js"></script>
  <script src="https://whatthefox.dev/search_index.en.js"></script><script src="https://whatthefox.dev/js/site.js"></script>

  





  
  
</body>

</html>
